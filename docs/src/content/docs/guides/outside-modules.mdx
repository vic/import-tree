---
title: Outside Module Evaluation
description: Use import-tree to list files programmatically, without importing them as modules.
---

## Using import-tree as a File Lister

`import-tree` doesn't have to produce module imports. You can use it to get a plain list of files:

```nix
(import-tree.withLib pkgs.lib).leafs ./modules
# => [ /path/to/modules/a.nix /path/to/modules/b.nix ]
```

### withLib

Outside module evaluation, `import-tree` needs access to `lib` (specifically `lib.filesystem.listFilesRecursive`). Call `.withLib` before `.leafs` or `.pipeTo`:

```nix
import-tree.withLib lib
```

Omitting `.withLib` when calling `.leafs` produces an error:
`"You need to call withLib before trying to read the tree."`

### leafs

`.leafs` returns a configured import-tree that, when given a path, produces a flat list of discovered files:

```nix
(import-tree.withLib lib).leafs ./src
# => [ ./src/main.nix ./src/utils.nix ]
```

### files

`.files` is a shortcut for `.leafs.result` — returns the list directly when paths have already been added via `.addPath`:

```nix
lib.pipe import-tree [
  (i: i.addPath ./modules)
  (i: i.withLib lib)
  (i: i.files)
]
```

### pipeTo

`.pipeTo` takes a function that receives the list of discovered paths, letting you process the results:

```nix
(import-tree.withLib lib).pipeTo builtins.length ./modules
# => 5  (number of .nix files)
```

Combine with `.map` for powerful pipelines:

```nix
lib.pipe import-tree [
  (i: i.map import)
  (i: i.pipeTo lib.length)
  (i: i.withLib lib)
  (i: i ./modules)
]
```

### result

`.result` evaluates the import-tree with an empty path list — useful when paths are already configured via `.addPath`:

```nix
(import-tree.addPath ./modules).result
# equivalent to:
(import-tree.addPath ./modules) []
```
